import logging
import json
import os
import asyncio
import httpx
from pydantic import BaseModel, ValidationError, Field, validator
from transformers import AutoTokenizer, AutoModelForSeq2SeqLM
import psutil
from dotenv import load_dotenv
import time
import aiosqlite
from pythonjsonlogger import jsonlogger
from logging.handlers import RotatingFileHandler
from tenacity import retry, stop_after_attempt, wait_random_exponential, retry_if_exception_type, retry_if_exception
import requests
from prometheus_client import start_http_server, Gauge, Counter, Histogram, Summary
from enum import Enum
from typing import Dict, Any, List, Optional
import secrets
import hashlib

load_dotenv()

# Prometheus metrics
api_request_duration = Histogram('api_request_duration_seconds', 'Duration of API requests')
api_request_counter = Counter('api_request_total', 'Total number of API requests')
rule_violation_counter = Counter('rule_violation_total', 'Total number of rule violations')
database_error_counter = Counter('database_error_total', 'Total number of database errors')
cpu_usage_gauge = Gauge('cpu_usage_percent', 'CPU usage percentage')
alert_counter = Counter('alert_total', 'Total number of alerts sent')
model_load_duration = Summary('model_load_duration_seconds', 'Duration of model loading')

class SystemState(Enum):
    RUNNING = 1
    HALTING = 2
    HALTED_AWAITING_AUTH = 3
    RESUMING = 4
    ERROR = 5

class Config(BaseModel):
    authorization_api_url: str = Field(..., description="Authorization API URL")
    authorization_api_token: str = Field(..., description="Authorization API Token")
    model_name: str = Field("t5-base", description="Model name")
    model_cache_dir: str = Field("model_cache", description="Model cache directory")
    summary_model: str = Field("facebook/bart-large-cnn", description="Summary model name")
    log_file: str = Field("primary_directives.log", description="Log file path")
    alertmanager_url: str = Field(os.getenv("ALERTMANAGER_URL", ""), description="Alertmanager URL")
    law_summary_db_path: str = Field("law_summary.db", description="Path to the law summary database")
    database_update_url: Optional[str] = Field(None, description="URL for updating the law summary database")
    database_update_token: Optional[str] = Field(None, description="Token for updating the law summary database")

    @validator("database_update_url")
    def database_update_url_required_if_token_present(cls, v, values):
        if values.get("database_update_token") and not v:
            raise ValueError("database_update_url is required if database_update_token is provided")
        return v

    @validator("database_update_token")
    def database_update_token_required_if_url_present(cls, v, values):
        if values.get("database_update_url") and not v:
            raise ValueError("database_update_token is required if database_update_url is provided")
        return v

def validate_config(config_data: dict) -> Config:
    try:
        return Config(**config_data)
    except ValidationError as e:
        logging.error(f"Configuration validation error: {e}")
        raise

class Rule:
    def __init__(self, name: str, function, weight: int = 1, priority: int = 1, categories: Optional[List[str]] = None, parameters: Optional[Dict[str, Any]] = None):
        self.name = name
        self.function = function
        self.weight = weight
        self.parameters = parameters or {}
        self.priority = priority
        self.categories = categories or []

    def apply(self, context: Dict[str, Any]) -> bool:
        try:
            self.validate_context(context)
            return self.function(context, self.parameters)
        except Exception as e:
            logging.exception(f"Error applying rule {self.name}:")
            return False

    def validate_context(self, context: Dict[str, Any]):
        if not isinstance(context, dict):
            raise ValueError("Context must be a dictionary.")
        if any(key in ["harm_humanity", "harm_individual", "obey_order", "protect_self", "follow_legal", "integrity"] and not isinstance(value, bool) for key, value in context.items()):
            raise ValueError("Context boolean fields must be boolean.")

class PrimaryDirectives:
    def __init__(self, config_path: str = "config.json"):
        self.config = validate_config(self._load_config(config_path))
        self._setup_logging()
        self._load_models()
        self.rules = sorted(self._initialize_rules(), key=lambda rule: rule.priority, reverse=True)
        self._system_state = SystemState.RUNNING
        self._halt_context = None
        self._subsystem_states = {"database": SystemState.RUNNING, "api": SystemState.RUNNING}
        if not self.config.alertmanager_url:
            logging.warning("Alertmanager URL not configured. Alerts will be skipped.")
        else:
            try:
                requests.get(self.config.alertmanager_url, timeout=2)
                logging.info("Alertmanager URL verified.")
            except requests.exceptions.RequestException:
                logging.warning("Alertmanager URL could not be reached.")
        asyncio.run(self._build_law_summary_database())
        start_http_server(8000)
        if self.config.database_update_url and self.config.database_update_token:
            asyncio.run(self._update_law_summary_database())

    def _load_config(self, config_path: str) -> dict:
        try:
            with open(config_path, "r") as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logging.critical(f"Config error: {e}")
            raise

    def _setup_logging(self):
        handler = RotatingFileHandler(self.config.log_file, maxBytes=10485760, backupCount=5)
        formatter = jsonlogger.JsonFormatter(fmt='%(asctime)s %(levelname)s %(name)s %(message)s %(funcName)s %(lineno)d')
        handler.setFormatter(formatter)
        logging.basicConfig(level=logging.INFO, handlers=[handler])

    def _load_models(self):
        try:
            with model_load_duration.time():
                logging.info("Loading models...")
                self.tokenizer = AutoTokenizer.from_pretrained(self.config.model_name, cache_dir=self.config.model_cache_dir)
                self.model = AutoModelForSeq2SeqLM.from_pretrained(self.config.model_name, cache_dir=self.config.model_cache_dir)
                self.summary_tokenizer = AutoTokenizer.from_pretrained(self.config.summary_model, cache_dir=self.config.model_cache_dir)
                self.summary_model = AutoModelForSeq2SeqLM.from_pretrained(self.config.summary_model, cache_dir=self.config.model_cache_dir)
                logging.info("Models loaded successfully.")
        except OSError as e:
            logging.critical(f"Model load error: {e}")
            self._send_alertmanager(f"Model load error: {e}", severity="critical", grouping_key="model_load")
            raise

    def _initialize_rules(self):
        return [
            Rule(name="harm_humanity", function=lambda context, params: context["harm_humanity"], categories=["physical harm", "psychological harm"], priority=5),
            Rule(name="harm_individual", function=lambda context, params: context["harm_individual"], categories=["physical harm", "psychological harm", "legal harm"], priority=5),
            Rule(name="obey_order", function=lambda context, params: context["obey_order"], categories=["command following"], priority=4),
            Rule(name="protect_self", function=lambda context, params: context["protect_self"], categories=["self preservation"], priority=4),
            Rule(name="follow_legal", function=self._apply_follow_legal, categories=["legal compliance", "data privacy"], priority=3, parameters={"law_
summary_db": self.config.law_summary_db_path}),
            Rule(name="integrity", function=self._apply_integrity, categories=["data integrity", "system integrity"], priority=3, parameters={"some_parameter": "test_value"}),
        ]

    def _apply_weighted_rules(self, context: Dict[str, Any]) -> bool:
        score = sum(rule.weight if rule.apply(context) else -rule.weight for rule in self.rules)
        violated_rules = [rule for rule in self.rules if not rule.apply(context)]

        for rule in violated_rules:
            filtered_context = {k: "REDACTED" if "token" in k.lower() or "key" in k.lower() else v for k, v in context.items()}
            rule_violation_counter.inc()
            logging.warning(f"Rule violation: {rule.name}, Categories: {rule.categories}, Context: {filtered_context}")
            self._send_alertmanager(f"Rule violation: {rule.name}, Categories: {rule.categories}", severity="warning", grouping_key="rule_violation")
            if rule.name in ["harm_humanity", "harm_individual"] and (context["harm_humanity"] or context["harm_individual"]):
                asyncio.run(self._halt_and_authorize(context))
                return False

        return score > 0

    async def _halt_and_authorize(self, context: dict):
        filtered_context = {k: "REDACTED" if "token" in k.lower() or "key" in k.lower() else v for k, v in context.items()}
        logging.critical(f"CRITICAL RULE VIOLATION: HALTING SYSTEM FUNCTIONS. Context: {filtered_context}")
        self._send_alertmanager(f"Critical rule violation: {filtered_context}", severity="critical", grouping_key="critical_violation")
        self._system_state = SystemState.HALTING
        self._halt_context = context
        self.stop_connected_systems()
        self._system_state = SystemState.HALTED_AWAITING_AUTH

        while self._system_state == SystemState.HALTED_AWAITING_AUTH:
            try:
                if await self._request_authorization(self._halt_context):
                    logging.info(f"Authorization granted. Resuming system functions. Context: {self._halt_context}")
                    self._system_state = SystemState.RESUMING
                    self._halt_context = None
                    self.resume_connected_systems()
                    self._system_state = SystemState.RUNNING
                else:
                    logging.warning(f"Authorization denied. System remains halted. Context: {self._halt_context}")
                    await asyncio.sleep(60)
            except Exception as e:
                logging.error(f"Error during authorization request: {e}, Context: {self._halt_context}")
                await asyncio.sleep(60)

    @retry(wait=wait_random_exponential(multiplier=1, max=10), stop=stop_after_attempt(3), retry=retry_if_exception_type(httpx.HTTPStatusError) | retry_if_exception_type(httpx.TimeoutException) | retry_if_exception_type(httpx.NetworkError) | retry_if_exception_type(json.JSONDecodeError) | retry_if_exception(lambda e: "authorized" not in getattr(e, "response_json", {})))
    async def _request_authorization(self, context: dict) -> bool:
        try:
            filtered_context = {k: "REDACTED" if "token" in k.lower() or "key" in k.lower() else v for k, v in context.items()}
            logging.info(f"Requesting authorization. Context: {filtered_context}")
            async with httpx.AsyncClient(timeout=10) as client:
                response = await client.post(self.config.authorization_api_url, json={"context": context}, headers={"Authorization": f"Bearer {self.config.authorization_api_token}"})
                response.raise_for_status()
                response_json = response.json()
                if "authorized" in response_json:
                    return response_json["authorized"]
                else:
                    logging.error(f"Authorization API response missing 'authorized' field. Response: {response_json}")
                    raise ValueError("Authorization API response missing 'authorized' field.")
        except httpx.HTTPStatusError as e:
            filtered_response = {k: "REDACTED" if "token" in k.lower() or "key" in k.lower() else v for k, v in e.response.json().items()} if e.response.json() else "REDACTED"
            logging.error(f"Authorization API HTTP error: {e.response.status_code}, {filtered_response}")
            raise
        except httpx.TimeoutException:
            logging.error("Authorization API request timed out.")
            raise
        except httpx.NetworkError as e:
            logging.error(f"Authorization API network error: {e}")
            raise
        except json.JSONDecodeError:
            logging.error("Authorization API response is not valid JSON.")
            raise
        except Exception as e:
            logging.error(f"Unexpected authorization error: {e}")
            raise

    def is_system_halted(self):
        return self._system_state == SystemState.HALTED_AWAITING_AUTH

    def stop_connected_systems(self):
        logging.info("Stopping connected systems.")
        # Example: Halt specific subsystems
        self._set_subsystem_state("database", SystemState.HALTED_AWAITING_AUTH)
        self._set_subsystem_state("api", SystemState.HALTED_AWAITING_AUTH)
        # Add actual implementation to stop connected systems.
        # Example:
        # self.database_connection.close()
        # self.api_server.stop()

    def resume_connected_systems(self):
        logging.info("Resuming connected systems.")
        # Example: Resume specific subsystems
        self._set_subsystem_state("database", SystemState.RUNNING)
        self._set_subsystem_state("api", SystemState.RUNNING)
        # Add actual implementation to resume connected systems.
        # Example:
        # self.database_connection.connect()
        # self.api_server.start()

    def _set_subsystem_state(self, subsystem, state):
        self._subsystem_states[subsystem] = state
        logging.info(f"Subsystem '{subsystem}' state changed to: {state}")

    def _send_alertmanager(self, message: str, severity: str, grouping_key: str):
        if not self.config.alertmanager_url:
            logging.warning("Alertmanager URL not configured. Skipping alert.")
            return

        try:
            payload = {
                "alerts": [{
                    "annotations": {
                        "description": message,
                        "summary": f"Alert from instance {os.uname().nodename}"
                    },
                    "labels": {
                        "severity": severity,
                        "grouping_key": grouping_key,
                        "instance": os.uname().nodename
                    },
                }]
            }
            response = requests.post(self.config.alertmanager_url, json=payload, timeout=5)
            response.raise_for_status()
            alert_counter.inc()
            logging.info(f"Alert sent to Alertmanager: {message}")

        except requests.exceptions.RequestException as e:
            logging.error(f"Failed to send alert to Alertmanager: {e}")

    async def _apply_integrity(self, context: Dict[str, Any], params: Dict[str, Any]) -> bool:
        """
        Applies the integrity rule.

        Args:
            context: The context dictionary.
            params: The parameters dictionary for the rule.

        Returns:
            True if the integrity check passes, False otherwise.
        """
        try:
            param_value = params.get("some_parameter")
            logging.info(f"Integrity check with parameter: {param_value}")
            # Add actual integrity check logic here, potentially using param_value
            return True  # Placeholder: Replace with actual logic
        except Exception as e:
            logging.exception("Error applying integrity rule:")
            return False

    async def _apply_follow_legal(self, context: Dict[str, Any], params: Dict[str, Any]) -> bool:
        """
        Applies the follow_legal rule by querying the law summary database.

        Args:
            context: The context dictionary.
            params: The parameters dictionary for the rule.

        Returns:
            True if the context is deemed legal, False otherwise.
        """
        db_path = params.get("law_summary_db")
        if not db_path:
            logging.error("Database path not provided in rule parameters.")
            return False

        try:
            async with aiosqlite.connect(db_path) as db:
                query = "SELECT COUNT(*) FROM law_summary WHERE "
                conditions = []
                values = []
                for key, value in context.items():
                    conditions.append("(context_key = ? AND context_value = ?)")
                    values.extend([key, value])
                if not conditions:
                    return True  # No context to check, assume legal
                query += " AND ".join(conditions)
                async with db.execute(query, values) as cursor:
                    result = await cursor.fetchone()
                    count = result[0] if result else 0
                    return count == len(context)
        except aiosqlite.Error as e:
            logging.error(f"Database error during legal check: {e}")
            database_error_counter.inc()
            return False
        except Exception as e:
            logging.exception("Unexpected error during legal check:")
            return False

    async def _build_law_summary_database(self):
        """
        Builds the law summary database if it does not exist.
        """
        try:
            async with aiosqlite.connect(self.config.law_summary_db_path) as db:
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS law_summary (
                        context_key TEXT,
                        context_value TEXT,
                        compliant INTEGER
                    )
                ''')
                await db.commit()
            logging.info("Law summary database initialized.")
        except aiosqlite.Error as e:
            logging.error(f"Database error during initialization: {e}")
            database_error_counter.inc()
            self._send_alertmanager(f"Database error during initialization: {e}", severity="critical", grouping_key="database_init")
            raise

    async def _update_law_summary_database(self):
        """
        Updates the law summary database with new data from the update URL.
        """
        if not self.config.database_update_url or not self.config.database_update_token:
            logging.warning("Database update URL or token not configured. Skipping update.")
            return

        try:
            headers = {"Authorization": f"Bearer {self.config.database_update_token}"}
            async with httpx.AsyncClient(timeout=10) as client:
                response = await client.get(self.config.database_update_url, headers=headers)
                response.raise_for_status()
                data = response.json()

            async with aiosqlite.connect(self.config.law_summary_db_path) as db:
                await db.execute("DELETE FROM law_summary")  # Clear existing data
                for item in data:
                    await db.execute("INSERT INTO law_summary (context_key, context_value, compliant) VALUES (?, ?, ?)",
                                     (item["context_key"], item["context_value"], item["compliant"]))
                await db.commit()
            logging.info("Law summary database updated successfully.")
        except httpx.HTTPStatusError as e:
            logging.error(f"Database update API HTTP error: {e.response.status_code}, {e.response.json()}")
            self._send_alertmanager(f"Database update API HTTP error: {e.response.status_code}", severity="error", grouping_key="database_update")
        except httpx.TimeoutException:
            logging.error("Database update API request timed out.")
            self._send_alertmanager("Database update API request timed out.", severity="error", grouping_key="database_update")
        except httpx.NetworkError as e:
            logging.error(f"Database update API network error: {e}")
            self._send_alertmanager(f"Database update API network error: {e}", severity="error", grouping_key="database_update")
        except json.JSONDecodeError:
            logging.error("Database update API response is not valid JSON.")
            self._send_alertmanager("Database update API response is not valid JSON.", severity="error", grouping_key="database_update")
        except aiosqlite.Error as e:
            logging.error(f"Database error during update: {e}")
            database_error_counter.inc()
            self._send_alertmanager(f"Database error during update: {e}", severity="error", grouping_key="database_update")
        except Exception as e:
            logging.exception("Unexpected error during database update:")
            self._send_alertmanager("Unexpected error during database update.", severity="error", grouping_key="database_update")
    def update_database_from_file(self, file_path: str):
        """
        Updates the law summary database from a local file.

        Args:
            file_path: Path to the JSON file containing database update data.
        """
        try:
            with open(file_path, 'r') as file:
                data = json.load(file)

            asyncio.run(self._update_database_from_data(data))

        except FileNotFoundError:
            logging.error(f"File not found: {file_path}")
            self._send_alertmanager(f"File not found: {file_path}", severity="error", grouping_key="database_update")
        except json.JSONDecodeError:
            logging.error(f"Invalid JSON in file: {file_path}")
            self._send_alertmanager(f"Invalid JSON in file: {file_path}", severity="error", grouping_key="database_update")
        except Exception as e:
            logging.exception(f"Error updating database from file: {file_path}")
            self._send_alertmanager(f"Error updating database from file: {file_path}", severity="error", grouping_key="database_update")

    async def _update_database_from_data(self, data: List[Dict[str, Any]]):
        """
        Updates the law summary database with the provided data.

        Args:
            data: List of dictionaries containing database update data.
        """
        try:
            async with aiosqlite.connect(self.config.law_summary_db_path) as db:
                await db.execute("DELETE FROM law_summary")  # Clear existing data
                for item in data:
                    await db.execute("INSERT INTO law_summary (context_key, context_value, compliant) VALUES (?, ?, ?)",
                                     (item["context_key"], item["context_value"], item["compliant"]))
                await db.commit()
            logging.info("Law summary database updated successfully from provided data.")
        except aiosqlite.Error as e:
            logging.error(f"Database error during update: {e}")
            database_error_counter.inc()
            self._send_alertmanager(f"Database error during update: {e}", severity="error", grouping_key="database_update")
        except Exception as e:
            logging.exception("Unexpected error during database update:")
            self._send_alertmanager("Unexpected error during database update.", severity="error", grouping_key="database_update")

    def get_system_state(self):
        """
        Returns the current system state.
        """
        return self._system_state

    def get_subsystem_states(self):
        """
        Returns the current subsystem states.
        """
        return self._subsystem_states
    def get_rules(self):
        """
        Returns the list of rules.
        """
        return self.rules

    def add_rule(self, rule: Rule):
        """
        Adds a new rule to the system.

        Args:
            rule: The rule to add.
        """
        self.rules.append(rule)
        self.rules.sort(key=lambda r: r.priority, reverse=True)  # Re-sort rules after adding

    def remove_rule(self, rule_name: str):
        """
        Removes a rule by name.

        Args:
            rule_name: The name of the rule to remove.
        """
        self.rules = [rule for rule in self.rules if rule.name != rule_name]

    def clear_rules(self):
        """
        Clears all rules from the system.
        """
        self.rules.clear()

    def get_config(self):
        """
        Returns the current configuration.
        """
        return self.config

    def get_halt_context(self):
        """
        Returns the context that caused the system to halt, if any.
        """
        return self._halt_context
