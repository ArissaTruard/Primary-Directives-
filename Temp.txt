<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"><title>Semantic Editor</title>
    <style>
        /* --- THEME --- */
        body { margin: 0; background: #0d1117; color: #c9d1d9; font-family: 'Consolas', 'Monaco', monospace; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* --- TOOLBAR --- */
        #toolbar { height: 32px; background: #161b22; border-bottom: 1px solid #30363d; display: flex; align-items: center; padding: 0 10px; gap: 10px; }
        button { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; }
        button:hover { background: #30363d; color: white; }
        button.primary { background: #238636; border-color: #238636; color: white; }

        /* --- SPLIT VIEW --- */
        #workspace { flex: 1; display: flex; overflow: hidden; }
        
        /* RAW EDITOR (Left) */
        #raw-layer { width: 0; flex: 0; transition: 0.2s; border-right: 1px solid #30363d; display: flex; flex-direction: column; }
        textarea { flex: 1; background: #0d1117; color: #c9d1d9; border: none; padding: 10px; resize: none; outline: none; white-space: pre; overflow: auto; font-family: inherit; font-size: 13px; line-height: 1.5; }

        /* BLOCK EDITOR (Right) */
        #block-layer { flex: 1; padding: 20px; overflow-y: auto; position: relative; }
        
        /* --- SEMANTIC BLOCKS --- */
        .block { 
            position: relative; margin-left: 20px; padding: 5px; 
            border-left: 2px solid #30363d; border-radius: 4px;
            transition: all 0.2s; background: rgba(255,255,255,0.02);
            margin-bottom: 4px;
        }
        
        /* Dragging Styles */
        .block.draggable { cursor: grab; }
        .block.dragging { opacity: 0.5; border: 2px dashed #58a6ff; background: #1f2428; }
        .block.drag-over { border-top: 2px solid #58a6ff; }

        /* Semantic Colors (From your Python snippet) */
        .type-class    { border-color: #d2a8ff; background: rgba(210, 168, 255, 0.05); } /* Purple */
        .type-function { border-color: #58a6ff; background: rgba(88, 166, 255, 0.05); } /* Blue */
        .type-subblock { border-color: #7ee787; background: rgba(126, 231, 135, 0.05); } /* Green */
        .type-comment  { border-color: #484f58; color: #8b949e; font-style: italic; }
        .type-import   { border-color: #8b949e; opacity: 0.8; }
        
        /* Header Row */
        .block-head { display: flex; align-items: center; gap: 8px; padding: 2px 5px; border-radius: 4px; }
        .block-head:hover { background: rgba(255,255,255,0.05); }
        
        .toggle-btn { cursor: pointer; width: 12px; height: 12px; display: flex; align-items: center; justify-content: center; font-size: 10px; color: #8b949e; }
        .block-name { font-weight: bold; color: inherit; flex: 1; }
        .block-type { font-size: 10px; opacity: 0.5; text-transform: uppercase; }

        /* Collapsed State */
        .block.collapsed .block-body { display: none; }
        .block.collapsed::after { content: '...'; opacity: 0.5; margin-left: 10px; }

        /* Editable Lines */
        .code-line { padding: 0 5px; border-radius: 2px; cursor: text; min-height: 18px; }
        .code-line:hover { background: rgba(255,255,255,0.05); }
        .code-line:focus { background: #161b22; outline: none; color: white; }
    </style>
</head>
<body>

    <div id="toolbar">
        <span style="font-weight:bold; color:#58a6ff;">üì¶ Semantic Editor</span>
        <div style="flex:1"></div>
        <button onclick="Editor.toggleRaw()" title="Toggle Raw Text View">üìù Split View</button>
        <button onclick="Editor.save()" class="primary">üíæ Save</button>
    </div>

    <div id="workspace">
        <div id="raw-layer">
            <textarea id="raw-input" spellcheck="false" oninput="Editor.parseFromRaw()"></textarea>
        </div>
        <div id="block-layer"></div>
    </div>

    <script>
        // --- 1. THE BLOCK TREE LOGIC (Ported from your Python) ---
        
        const COLOR = {
            "class": "type-class",
            "function": "type-function",
            "subblock": "type-subblock",
            "import": "type-import",
            "comment": "type-comment",
            "code": "type-code"
        };

        class Block {
            constructor(type, name, indent, lineStr) {
                this.type = type;
                this.name = name;
                this.indent = indent;
                this.lines = lineStr ? [lineStr] : [];
                this.children = [];
                this.collapsed = false;
                this.id = Math.random().toString(36).substr(2, 9); // Unique ID for DragDrop
            }
        }

        const Parser = {
            parse(text) {
                const lines = text.split('\n');
                const root = new Block("root", "ROOT", -4, "");
                const stack = [root];

                lines.forEach(line => {
                    if(!line.trim()) {
                         // Attach empty lines to current leaf
                         stack[stack.length-1].lines.push(line);
                         return;
                    }

                    const indent = line.search(/\S|$/);
                    const stripped = line.trim();
                    
                    // Logic: Find parent with strictly LESS indent
                    while(stack.length > 1 && stack[stack.length-1].indent >= indent) {
                        stack.pop();
                    }
                    const parent = stack[stack.length-1];

                    // Identify Block Type
                    let type = "code";
                    let name = "";
                    
                    if(stripped.startsWith("class ")) { type = "class"; name = stripped.split(' ')[1].replace(':',''); }
                    else if(stripped.startsWith("def ")) { type = "function"; name = stripped.split(' ')[1].split('(')[0]; }
                    else if(stripped.startsWith("#")) { type = "comment"; name = stripped; }
                    else if(stripped.startsWith("import ") || stripped.startsWith("from ")) { type = "import"; name = "import"; }
                    else if(stripped.endsWith(":")) { type = "subblock"; name = stripped.replace(':',''); }
                    
                    // Decide: Is this a new structural block or just a line of code?
                    // Structure blocks are classes, functions, or anything that increases indent level
                    if (["class", "function", "subblock"].includes(type)) {
                        const newBlock = new Block(type, name, indent, line);
                        parent.children.push(newBlock);
                        stack.push(newBlock);
                    } else {
                        // Just append line to current block
                        // OR if indent matches parent indent, maybe it belongs to parent?
                        // For simplicity in this v1, code lines live in the block they are inside
                        // We check if we need to create a "code chunk" or append to last child
                        const last = parent.children[parent.children.length-1];
                        if(last && last.type === 'code' && last.indent === indent) {
                            last.lines.push(line);
                        } else {
                            // New generic code block
                            const codeBlock = new Block("code", "...", indent, line);
                            parent.children.push(codeBlock);
                        }
                    }
                });

                return root;
            },

            renderToText(block) {
                let out = "";
                block.children.forEach(child => {
                    child.lines.forEach(l => out += l + "\n");
                    out += this.renderToText(child);
                });
                return out;
            }
        };

        // --- 2. THE UI RENDERER ---

        const Editor = {
            root: null,
            dragSrc: null,

            init() {
                // Initial Demo Code
                const demo = [
                    "import sys",
                    "# This is a semantic editor",
                    "",
                    "class Hero:",
                    "    def __init__(self, name):",
                    "        self.name = name",
                    "        self.power = 100",
                    "",
                    "    def fly(self):",
                    "        print(self.name + ' is flying')",
                    "        if self.power > 0:",
                    "            self.power -= 10"
                ].join('\n');
                
                document.getElementById('raw-input').value = demo;
                this.parseFromRaw();
            },

            toggleRaw() {
                const el = document.getElementById('raw-layer');
                el.style.width = el.style.width === '50%' ? '0' : '50%';
                el.style.flex = el.style.flex === '1' ? '0' : '1';
            },

            parseFromRaw() {
                const text = document.getElementById('raw-input').value;
                this.root = Parser.parse(text);
                this.renderTree();
            },

            renderTree() {
                const container = document.getElementById('block-layer');
                container.innerHTML = '';
                // Skip root, render children
                this.root.children.forEach(child => {
                    container.appendChild(this.createBlockElement(child));
                });
            },

            createBlockElement(block) {
                const el = document.createElement('div');
                el.className = `block ${COLOR[block.type] || ''}`;
                if(block.collapsed) el.classList.add('collapsed');
                el.draggable = true;

                // Drag Events
                el.addEventListener('dragstart', e => { 
                    this.dragSrc = block; 
                    e.dataTransfer.effectAllowed = 'move';
                    el.classList.add('dragging');
                    e.stopPropagation(); // Don't drag parent
                });
                el.addEventListener('dragend', () => el.classList.remove('dragging'));
                el.addEventListener('dragover', e => { e.preventDefault(); el.classList.add('drag-over'); return false; });
                el.addEventListener('dragleave', () => el.classList.remove('drag-over'));
                el.addEventListener('drop', e => {
                    e.stopPropagation();
                    el.classList.remove('drag-over');
                    this.handleDrop(block);
                });

                // Header
                const head = document.createElement('div');
                head.className = 'block-head';
                
                // Toggle
                const tog = document.createElement('span');
                tog.className = 'toggle-btn';
                tog.innerHTML = block.collapsed ? '‚ñ∂' : '‚ñº';
                if(block.children.length === 0) tog.innerHTML = '‚Ä¢';
                tog.onclick = () => { block.collapsed = !block.collapsed; this.renderTree(); };

                // Name/Code
                const title = document.createElement('span');
                title.className = 'block-name';
                title.innerText = block.name || block.lines[0].trim();
                
                // If it's just code, make it editable text
                if(block.type === 'code' || block.type === 'import') {
                    title.contentEditable = true;
                    title.className = 'code-line';
                    title.innerText = block.lines.join('\n');
                    title.oninput = (e) => { block.lines = e.target.innerText.split('\n'); this.syncToRaw(); };
                    // Disable header styling for raw code
                    el.style.borderLeft = 'none';
                    el.style.padding = '0';
                    head.style.display = 'none'; // Hide header for pure code
                    el.appendChild(title);
                } else {
                    head.appendChild(tog);
                    head.appendChild(title);
                    
                    const meta = document.createElement('span');
                    meta.className = 'block-type';
                    meta.innerText = block.type;
                    head.appendChild(meta);
                    el.appendChild(head);
                }

                // Children Container
                const body = document.createElement('div');
                body.className = 'block-body';
                
                // If a structural block has lines of its own definition (like 'def foo():')
                // We rendered that in the header.
                // Now render children
                block.children.forEach(child => {
                    body.appendChild(this.createBlockElement(child));
                });
                el.appendChild(body);

                return el;
            },

            handleDrop(targetBlock) {
                if(this.dragSrc === targetBlock) return;
                
                // Simple Logic: Move Src to be a child of Target
                // 1. Remove from old parent
                this.removeFromTree(this.root, this.dragSrc);
                
                // 2. Add to new target
                targetBlock.children.push(this.dragSrc);
                
                // 3. Re-indent logic would go here (update indentation of src based on target)
                this.recalcIndent(this.dragSrc, targetBlock.indent + 4);

                this.syncToRaw();
                this.renderTree();
            },

            removeFromTree(parent, target) {
                const idx = parent.children.indexOf(target);
                if(idx > -1) {
                    parent.children.splice(idx, 1);
                    return true;
                }
                for(let c of parent.children) {
                    if(this.removeFromTree(c, target)) return true;
                }
                return false;
            },

            recalcIndent(block, newIndent) {
                // Calculate delta
                const oldIndent = block.lines[0].search(/\S|$/);
                const delta = newIndent - oldIndent;

                // Apply to self
                block.lines = block.lines.map(l => {
                    const content = l.trimStart();
                    return " ".repeat(newIndent) + content;
                });
                block.indent = newIndent;

                // Apply to children recursively
                block.children.forEach(c => this.recalcIndent(c, newIndent + 4));
            },

            syncToRaw() {
                const text = Parser.renderToText(this.root);
                document.getElementById('raw-input').value = text;
            },

            async save() {
                const content = document.getElementById('raw-input').value;
                const urlParams = new URLSearchParams(window.location.search);
                const path = urlParams.get('file'); // ?file=tools/test.py
                
                if(path) {
                    await fetch('/io/save', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({path, content})
                    });
                    alert('Saved!');
                } else {
                    alert('No file path specified. (Open with ?file=...)');
                }
            }
        };

        // Boot
        // Check if file provided in URL
        const p = new URLSearchParams(window.location.search);
        const f = p.get('file');
        if(f) {
            fetch('/io/read', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({path:f})})
            .then(r=>r.json()).then(d => {
                if(d.status === 'success') {
                    document.getElementById('raw-input').value = d.content;
                    Editor.parseFromRaw();
                }
            });
        } else {
            Editor.init();
        }

    </script>
</body>
</html>
